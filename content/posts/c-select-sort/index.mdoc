---
title: C 选择排序
status: publish
published_time: 2018-10-27T00:00
modified_time: 2021-07-28T07:39
layout: post
categories:
  - 折腾记录
tags:
  - Develop
  - 算法
  - C
---

> 就按上一篇的格式写吧，其实还有很多 C 笔记可以水几篇文章，偷懒中。。

# 思想和举例

选择排序同样是通过遍历的方式进行比较排序的，只不过不再是通过不断交换相邻的两个数字，而是遍历搜索最大或最小值然后将最大值或最小值与最后方或者最前方的值进行交换，以此类推直到最后完成排序，具体排序的过程可以查看维基百科，偷懒。。

看什么呢，没有举例~(￣ ▽ ￣)~

# 算法总结与实现

不用介绍了直接上算法吧(￣ ▽ ￣)"

```c
#include <stdio.h>
#define N 10 //定义要排序的数组长度
//选择排序控制Demo
//选择排序结果和方式
//结果：输出排序的数组
//方式：遍历比较
//本例排序从低到高
int main(int argc, char const *argv[])
{
    int nums[N], temp, j, i;
    printf ("请输入要进行排序的数列：\n");
    for (int u = 0; u < 10; u++) //循环输入数组
    {
        scanf ("%d", &nums[u]);
    }

    //
    //升序排列
    //
    printf ("降序排列：\n");
    for (i = 0; i < N; i++) //外层循环，控制循环轮数
    {
        int m = i;
        for (j = i + 1; j < N; j++) //内层循环，控制遍历数组，寻找最小的数，并进行交换指针
        {
            if (nums[m] > nums[j]) //判断附近两个数谁最小
            {
                m = j; //标记最小的数
            }
        }
        temp = nums[m]; //交换最小的数到前方
        nums[m] = nums[i];
        nums[i] = temp;
    }

    //输出排序好是数组
    int u;
    for (u = 0; u < N - 1; u++)
    {
        printf ("%d ", nums[u]);
    }
    printf ("%d\n",nums[u]);

    //
    //降序排列
    //
    //输出排序好是数组
    for (u = N - 1; u > 0; u--)
    {
        printf ("%d ", nums[u]);
    }
    printf ("%d\n",nums[u]);

    return 0;
}
```

对了，这次采用了循环输入，不用再写很长的输入了ヾ(≧▽≦\*)o
